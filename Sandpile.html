<!--
 Abelian Sandpile Simulator
 
 -->
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
            <title>Sandpile</title>
            <script type="text/javascript" src="./webgl-utils.js"></script>
            
            
            <!-- Fragment Shader, tells screen what colors to be displayed -->
            <script id="frag_draw_tex" type="x-shader/x-fragment">#version 300 es
                precision mediump float; //set precision since shaders don't have a default precision
                uniform sampler2D tex1; // The texture
                out vec4 color; // output color
                
                void main(void) {
                    // Reads the texture.
                    float pc = texture(tex1,vec2((gl_FragCoord.x)/512.0,(gl_FragCoord.y)/512.0)).x;
                    // gl_FragCoords.xy give the screen space coordinate of current pixel based on viewport size. Dividing by the viewport size (512 in this case) give a number in [0,1] that can be used as texture coordinates.
                    // Here we tex1.x will be 0,1,2,...,max_height (amount of sand at location).
                    
                    // Output color.
                    color = vec4(mix(vec3(0.0,0.0,0.0),vec3(0.0,0.0,255.0),0.25*pc),1.0);
                    // mix() linearly interpolates bw the 2 vec3's with weight (1/max_height)*pc
                    return;
                }
            </script>
            
            
            <!-- Vertex Shader -->
            <script id="vert_pass" type="x-shader/x-vertex">#version 300 es
                precision mediump float; //set precision since shaders don't have a default precision
                layout(location = 0) in vec3 aVertexPosition; // assigns the input variable aVertexPosition the index 0
                // must return gl_Position (predefined output of type vec4)
                void main(void) { gl_Position = vec4(aVertexPosition,1.0);  }
            </script>
            
            
            <!-- All our functions -->
            <script type="text/javascript">
            
            
                var gl;
                
                // The square on top of which the texture is rendered.
                var SVAO, SL;
                
                // Shader that draws the texture.
                var sh_draw_tex;
            
                const N = 128; // Size of Lattice
                const max_height = 3; // max pile height before sand topples
                
                // The flattened lattice packed into a RGBA texture.
                // Each lattice site (i,j) has associated to it four 8-bit integers:
                // lattice[4*(i*N+j)+0],lattice[4*(i*N+j)+1],
                // lattice[4*(i*N+j)+2], lattice[4*(i*N+j)+3]
                const lattice = new Uint8Array(4*N*N); // by default zero filled
                
                // GPU texture object
                var tex1;
            
            
                function tick() {
                    // add a piece of sand at origin, deal with all collapses.
                    // draw resulting configuration (maybe every hundred grains or so)
                    // run tick again.
                    
                    var still_falling = true;
                    var ip = N/2 - 1; var jp = N/2 - 1;
                    while (still_falling) {
                        for (var i=0; i < 10; ++i) {
                            //ip = Math.floor(u01()*N);
                            //jp = Math.floor(u01()*N);
                            dropGrain(ip,jp);
                        }
                        still_falling = false;
                    }
                    
                    loadTextures(); //set up the 2D textures
                    drawScene(); // run shaders and draw
                    requestAnimFrame(tick); // requestAnimFrame will run tick() as soon as the screen is ready to accept next redraw. Calling it recursively animates the scene
                    
                }
            
                function dropGrain(ii, jj) {
                    if (lattice[4*(ii*N+jj)] == max_height) {
                        lattice[4*(ii*N+jj)] = 0;
                        if ( ii > 0 ) {
                            dropGrain(ii-1,jj);
                        }
                        if ( ii < N-1 ) {
                            dropGrain(ii+1,jj);
                        }
                        if ( jj > 0 ) {
                            dropGrain(ii,jj-1);
                        }
                        if ( jj < N-1 ) {
                            dropGrain(ii,jj+1);
                        }
                    } else {
                        lattice[4*(ii*N+jj)]++;
                    }
                }
            
                function initLattice() {
                    for (var i = 0; i < N; i++) {
                        for (var j = 0; j < N; j++) {
                            lattice[4*(i*N+j)] = 0;
                        }
                    }
                }
            
            
                function u01() {
                    return Math.random();
                }
                
                function webGLStart() {
                    var canvas = document.getElementById("canvas"); // get the HTML canvas to draw on
                    
                    try {
                        // try to start a webgl2 context. Buffers won't be cleared and will preserve value until cleared or overwritten by author
                        gl = canvas.getContext("webgl2", { preserveDrawingBuffer: false });
                        // set viewport width and height
                        gl.viewportWidth = canvas.width; gl.viewportHeight = canvas.height;
                    } catch (e) { }
                    // if pointer to context is null
                    if (!gl) { alert("Could not initialise WebGL, sorry :-("); }
                    
                    gl.disable(gl.DEPTH_TEST); // no depth test before/after fragment shader
                    gl.enable(gl.BLEND); // blending on. blends new pixel with old pixel
                    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA); // with this blend function
                    
                    loadShaders();
                    tex1 = gl.createTexture();
                    loadTextures();
                    
                    
                    // how to apply texture to surface
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                    
                    // square
                    vertices = [1.0, 1.0, 0.0, -1.0, 1.0, 0.0, 1.0, -1.0, 0.0, -1.0, -1.0, 0.0 ];
                    ebo = [0,1,2,1,2,3];
                    
                    
                    SVAO = gl.createVertexArray(); SL = 6; // create vertex array operator, 6 vertices for the square
                    gl.bindVertexArray(SVAO); // bind it to our context
                    gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer()); // create a a verex attribute buffer and bind it
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW); // add vertex data to buffer. State that it is static.
                    gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0); // index of attribute, number of components, data type, dont normalize, generic stride, no offset
                    gl.enableVertexAttribArray(0); // enable attribute at index 0
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer()); // create and bind an element array buffer
                    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,  new Uint16Array(ebo), gl.STATIC_DRAW); // add data to buffer
                    
                    gl.bindFramebuffer(gl.FRAMEBUFFER, null); // render to canvas
                    
                    document.onmousedown = handleMouseDown;
                    document.onmouseup = handleMouseUp;
                    document.onkeydown = handleKeyDown;
                    document.onmousemove = handleMouseMove;
                    document.onmouseout = handleMouseUp;
                    
                    initLattice();
                    tick();
                }
            
                function drawScene() {
                    // using the vao and ebo we draw a square covering the whole viewbox.
                    // we color the square using the texture we get from lattice.
                    // our fragment shader turns the value of lattice at the point (i,j) (0 or 1) into a color (red or blue).
                    gl.useProgram(sh_draw_tex); // run the shader programs
                    gl.uniform1i(gl.getUniformLocation(sh_draw_tex, "tex1"), 0); // render tex1 with texture unit 0
                    gl.bindFramebuffer(gl.FRAMEBUFFER, null); // render to canvas
                    gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight); // convert clipspace to pixels
                    gl.bindVertexArray(SVAO);  gl.drawElements(gl.TRIANGLES, SL, gl.UNSIGNED_SHORT, 0); gl.bindVertexArray(null);
                    // bind vertex array. draw triangles, there are SL=6 vertices total (for each square), the data type, 0 offset. Then unbind vertex array.
                }
            
                function make_shader(vertshader, fragshader) {
                    var sp = gl.createProgram(); // create program
                    gl.attachShader(sp, getShader(gl, vertshader)); gl.attachShader(sp, getShader(gl, fragshader)); // attach shaders to program. getShader() did the creating and compiling of the shaders
                    gl.linkProgram(sp); // link shaders
                    if (!gl.getProgramParameter(sp, gl.LINK_STATUS)) { alert("Could not initialise shaders"); } // check if shaders linked properly
                    return sp;
                }
            
                function loadShaders() {
                    sh_draw_tex = make_shader("vert_pass","frag_draw_tex"); // make the shader program
                }
            
                function loadTextures() {
                    // make the 0th texture unit active. Binds a 2D texture named tex1 to the active texture unit.
                    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, tex1);
                    // first arg: type of texture
                    // sec arg: mipmap reduction level (?)
                    // third arg: internal format of texture
                    // 4 and 5: size of texture
                    // 6: width of border (must be 0)
                    // 7: format of texture data (must match internal format)
                    // 8: format of texture data
                    // 9: pointer to data in memory
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, N, N, 0, gl.RGBA, gl.UNSIGNED_BYTE, lattice); // write lattice to texture
                }
            
                function getShader(gl, id) {
                    var shaderScript = document.getElementById(id);
                    if (!shaderScript) { return null; }
                    
                    var str = "";
                    var k = shaderScript.firstChild;
                    while (k) {
                        if (k.nodeType == 3) {
                            str += k.textContent;
                        }
                        k = k.nextSibling;
                    }
                    
                    var shader;
                    if (shaderScript.type == "x-shader/x-fragment") {
                        shader = gl.createShader(gl.FRAGMENT_SHADER);
                    } else if (shaderScript.type == "x-shader/x-vertex") {
                        shader = gl.createShader(gl.VERTEX_SHADER);
                    } else {
                        return null;
                    }
                    
                    gl.shaderSource(shader, str);
                    gl.compileShader(shader);
                    
                    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                        alert(gl.getShaderInfoLog(shader));
                        return null;
                    }
                    return shader;
                }
                // ---- GUI stuff
                {
                    var drag = false; var cmx, cmy;
                    
                    function handleMouseDown(event) { }
                    function handleMouseMove(event) { }
                    function handleKeyDown(event) { }
                    function handleMouseUp(event) { }
                }
            
            </script>

    </head>
    
    <!-- on load runs webGLStart(), this will set up the required gl stuff and run ticK(). tick() does the markov chain stuff. -->
    <body  style="background-color:black;" onload="webGLStart();">
        <canvas id="canvas" style="border: none;" width="512" height="512" bg-color ="black"></canvas>
    </body>
</html>
